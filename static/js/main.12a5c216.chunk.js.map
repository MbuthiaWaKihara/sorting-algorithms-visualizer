{"version":3,"sources":["components/Title.js","components/Nav.js","components/Screen.js","components/App.js","components/algorithms.js","index.js"],"names":["React","memo","message","style","width","textAlign","color","height","currentArray","arrayHeight","length","displayArray","map","position","positionIndex","className","number","margin","marginBottom","borderTopLeftRadius","borderBottomLeftRadius","key","indexInArray","fontWeight","marginTop","marginLeft","initializeCurrentArray","counter","Math","floor","random","animationReference","useRef","useState","setCurrentArray","frameLength","setFrameLength","useEffect","current","console","log","clearInterval","Container","onClick","frames","decreasing","rawArray","swapped","holder","copyArray","push","JSON","parse","stringify","bubbleSort","sortedArray","setInterval","display","flexDirection","rootNode","document","querySelector","ReactDOM","render"],"mappings":"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","file":"static/js/main.12a5c216.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nconst Title = ({message}) => {\r\n    return (\r\n        <>\r\n            <div\r\n            style={{\r\n                width: '100%',\r\n                textAlign: 'center',\r\n                color: '#ffffff',\r\n            }}\r\n            >\r\n                {message}\r\n            </div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Title);","import React from 'react';\r\n\r\nconst Nav = () => {\r\n    return (\r\n        <>\r\n            <div\r\n            style={{\r\n                width: '20%',\r\n                height: '100%',\r\n                // border: '2px solid blue',\r\n            }}\r\n            >\r\n\r\n            </div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Nav);","import React from 'react';\r\n\r\nconst Screen = ({currentArray}) => {\r\n    let arrayHeight = (100 - ((currentArray.length - 1 ) * .25)) / currentArray.length;\r\n    let displayArray = currentArray.map(\r\n        (position, positionIndex) => {\r\n            return(\r\n                <div\r\n                className={position.className}\r\n                style={{\r\n                    width: `${position.number / 2 > 100 ? 100 : position.number / 2}%`,\r\n                    height: `${arrayHeight - .2}%`,\r\n                    margin: '0 0 0 auto',\r\n                    marginBottom: '.25%',\r\n                    borderTopLeftRadius: '5px',\r\n                    borderBottomLeftRadius: '5px',\r\n                }}\r\n                key={position.indexInArray}\r\n                >\r\n                    {currentArray.length <= 30 &&\r\n                        <div\r\n                        style={{\r\n                            // border: '2px solid black',\r\n                            color: '#ffffff',\r\n                            fontWeight: 'bolder',\r\n                            textAlign: 'center',\r\n                            width: '50px',\r\n                            height: '100%',\r\n                            margin: '0 0 0 auto',\r\n                        }}\r\n                        >{position.number}</div>\r\n                    }\r\n                </div>\r\n            );\r\n        }\r\n    ); \r\n    return (\r\n        <>\r\n            <div\r\n            style={{\r\n                width: '75%',\r\n                height: '90%',\r\n                // border: '2px solid red',\r\n                marginTop: '2%',\r\n                marginLeft: '5%',\r\n            }}\r\n            >\r\n                {displayArray}\r\n            </div>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(Screen);","/** top level state management component */\r\nimport React, {\r\n    useState,\r\n    useEffect,\r\n    useRef,\r\n} from 'react';\r\nimport { Container } from 'react-bootstrap';\r\nimport Title from './Title';\r\nimport Nav from './Nav';\r\nimport Screen from './Screen';\r\nimport { \r\n    bubbleSort,\r\n    selectionSort,\r\n    insertionSort,\r\n    mergeSort,\r\n    quickSort,\r\n } from './algorithms';\r\n\r\nconst initializeCurrentArray = () => {\r\n    let currentArray = [];\r\n    for(let counter = 0; counter < 20; counter++){\r\n        currentArray[counter] = {\r\n            number: Math.floor(Math.random() * 200) + 10,\r\n            indexInArray: counter,\r\n            className: 'initial',\r\n        }\r\n    }\r\n    return currentArray;\r\n}\r\nconst App = () => {\r\n    let animationReference = useRef();\r\n    let position = useRef(0);\r\n\r\n    //state variable for the array currently in focus\r\n    const [currentArray, setCurrentArray] = useState(initializeCurrentArray);\r\n\r\n    //state variable to store the number of frames for animation\r\n    const [frameLength, setFrameLength] = useState(0);\r\n\r\n    //CALLBACKS\r\n    //test response\r\n    const testResponse = () => {\r\n        let frames = bubbleSort(false, JSON.parse(JSON.stringify(currentArray)), currentArray.length);\r\n        let sortedArray = frames[frames.length - 1];\r\n        for(let counter = 0; counter < sortedArray.length; counter++){\r\n            sortedArray[counter].className = \"sorted\";\r\n        }\r\n        frames.push(JSON.parse(JSON.stringify(sortedArray)));\r\n        console.log(\"frames\", frames);\r\n        setFrameLength(frames.length);\r\n        animationReference.current = setInterval(() => {\r\n            // console.log(\"animation position: \", position.current);\r\n            setCurrentArray(frames[position.current]);\r\n            position.current += 1;\r\n        }, 200);\r\n    }    \r\n\r\n    //SIDE EFFECTS\r\n    //testing side effect\r\n    useEffect(() => {  \r\n        if(position.current === frameLength){\r\n            console.log(\"current array: \", currentArray);\r\n            clearInterval(animationReference.current);\r\n            setFrameLength(0);\r\n        }\r\n    }, [position.current, frameLength]);\r\n\r\n    return (\r\n        <>\r\n            <Container>\r\n                <Title\r\n                message=\"Sorting Algorithms Visualizer\"\r\n                />\r\n                <button onClick={testResponse}>Test</button>\r\n                <div\r\n                style={{\r\n                    display: 'flex',\r\n                    flexDirection: 'row',\r\n                    width: '100%',\r\n                    height: '80%',\r\n                }}\r\n                >\r\n                    <Nav/>\r\n                    <Screen\r\n                    currentArray={currentArray}\r\n                    />\r\n                </div>\r\n            </Container>\r\n        </>\r\n    );\r\n}\r\n\r\nexport default React.memo(App);","export const bubbleSort = (decreasing, rawArray) => {\r\n    let swapped;\r\n    let holder;\r\n    let copyArray = rawArray;\r\n    let frames = []; // this will hold all frames from the sorting process\r\n    while(true){\r\n        swapped = false;\r\n        for(let counter = 0; counter < rawArray.length - 1; counter++){ \r\n            copyArray[counter].className = \"inComparison\";\r\n            copyArray[counter + 1].className = \"inComparison\";\r\n            frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n            if(decreasing){\r\n                if(rawArray[counter].number < rawArray[counter + 1].number){\r\n                    copyArray[counter].className = \"wronglyOrdered\";\r\n                    copyArray[counter + 1].className = \"wronglyOrdered\";\r\n                    frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n    \r\n                    holder = copyArray[counter].number;\r\n                    copyArray[counter].number = copyArray[counter + 1].number;\r\n                    copyArray[counter + 1].number = holder;\r\n                    swapped = true;\r\n                    frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n                }\r\n\r\n            }else{\r\n                if(rawArray[counter].number > rawArray[counter + 1].number){\r\n                    copyArray[counter].className = \"wronglyOrdered\";\r\n                    copyArray[counter + 1].className = \"wronglyOrdered\";\r\n                    frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n    \r\n                    holder = copyArray[counter].number;\r\n                    copyArray[counter].number = copyArray[counter + 1].number;\r\n                    copyArray[counter + 1].number = holder;\r\n                    swapped = true;\r\n                    frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n                }\r\n            }\r\n\r\n            if(copyArray[counter].className !== \"initial\"){\r\n                copyArray[counter].className = \"initial\";\r\n                copyArray[counter + 1].className = \"initial\";\r\n                frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n            }\r\n        }\r\n\r\n        if(!swapped) break;\r\n    }\r\n\r\n    return frames;\r\n}\r\n\r\nexport const selectionSort = (decreasing, rawArray) => {\r\n    let selectionLimit = rawArray.length - 1;\r\n    let holder;\r\n    let copyArray = rawArray;\r\n    let frames = [];\r\n    let criteria;\r\n    let indexOfCriteria = null;\r\n\r\n    while(selectionLimit > 0) {\r\n        criteria  = decreasing ? Infinity : -Infinity;\r\n        \r\n        //find the largest number;\r\n        for(let counter = 0; counter <= selectionLimit; counter++) {\r\n            copyArray[counter].className = \"inComparison\";\r\n            frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n            if(decreasing){\r\n                if(copyArray[counter].number <= criteria) {\r\n                    //remove previous smallest\r\n                    if((indexOfCriteria || indexOfCriteria === 0) && indexOfCriteria !== selectionLimit + 1){\r\n                       copyArray[indexOfCriteria].className = \"initial\";\r\n                       frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n                   }\r\n   \r\n                   indexOfCriteria = counter;\r\n                   criteria = copyArray[counter].number;\r\n                   //target this one as smallest\r\n                   copyArray[counter].className = \"wronglyOrdered\";\r\n                   frames.push(JSON.parse(JSON.stringify(copyArray)));  \r\n               }\r\n            }else{\r\n                \r\n                if(copyArray[counter].number >= criteria) {\r\n                    //remove previous largest\r\n                    if((indexOfCriteria || indexOfCriteria === 0) && indexOfCriteria !== selectionLimit + 1){\r\n                       copyArray[indexOfCriteria].className = \"initial\";\r\n                       frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n                   }\r\n   \r\n                   indexOfCriteria = counter;\r\n                   criteria = copyArray[counter].number;\r\n                   //target this one as largest\r\n                   copyArray[counter].className = \"wronglyOrdered\";\r\n                   frames.push(JSON.parse(JSON.stringify(copyArray)));  \r\n               }\r\n            }\r\n\r\n            if(copyArray[counter].className !== \"wronglyOrdered\"){\r\n                copyArray[counter].className = \"initial\";\r\n                frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n            }\r\n\r\n        }\r\n        \r\n        if(indexOfCriteria !== selectionLimit){\r\n            copyArray[selectionLimit].className = \"wronglyOrdered\";\r\n            frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n        }\r\n\r\n        //swap the criteria to the index of current limit\r\n        holder = copyArray[selectionLimit].number;\r\n        copyArray[selectionLimit].number = copyArray[indexOfCriteria].number;\r\n        copyArray[indexOfCriteria].number = holder;\r\n        frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n\r\n        copyArray[selectionLimit].className = \"sorted\";\r\n        frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n        \r\n        selectionLimit--;\r\n    }\r\n\r\n    return frames;\r\n}\r\n\r\nexport const insertionSort = (decreasing, rawArray) => {\r\n    let holder;\r\n    let copyArray = rawArray;\r\n    let frames = [];\r\n    \r\n    for(let counter = 0; counter < copyArray.length; counter++) {\r\n        for(let compare = counter; compare > 0; compare--) {\r\n            copyArray[compare].className = \"inComparison\";\r\n            copyArray[compare - 1].className = \"inComparison\";\r\n            frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n            \r\n            if(decreasing){\r\n                if(copyArray[compare].number > copyArray[compare - 1].number) {\r\n                    copyArray[compare].className = \"wronglyOrdered\";\r\n                    copyArray[compare - 1].className = \"wronglyOrdered\";\r\n                    frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n    \r\n                    holder = copyArray[compare];\r\n                    copyArray[compare] = copyArray[compare - 1];\r\n                    copyArray[compare - 1] = holder;\r\n                    frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n                }\r\n\r\n            }else{\r\n                if(copyArray[compare].number < copyArray[compare - 1].number) {\r\n                    copyArray[compare].className = \"wronglyOrdered\";\r\n                    copyArray[compare - 1].className = \"wronglyOrdered\";\r\n                    frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n    \r\n                    holder = copyArray[compare];\r\n                    copyArray[compare] = copyArray[compare - 1];\r\n                    copyArray[compare - 1] = holder;\r\n                    frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n                }\r\n            }\r\n\r\n            copyArray[compare].className = \"initial\";\r\n            copyArray[compare - 1].className = \"initial\";\r\n            frames.push(JSON.parse(JSON.stringify(copyArray)));\r\n        }\r\n    }\r\n    \r\n    return frames;\r\n    \r\n}\r\n\r\nexport const quickSort = (decreasing, rawArray, start, end) => {\r\n    const partition = (rawArray, start, end) => {\r\n        \r\n        let subframes = [];\r\n        let pivot = rawArray[end].number;\r\n    \r\n        rawArray[end].className = \"wronglyOrdered\";\r\n        subframes.push(JSON.parse(JSON.stringify(rawArray)));\r\n\r\n        let pivotIndex = start - 1; // this value will be used to determine the sorted position of the pivot\r\n        let holder;\r\n        \r\n        for(let counter = start; counter <= end - 1; counter++){\r\n            rawArray[counter].className = \"inComparison\";\r\n            subframes.push(JSON.parse(JSON.stringify(rawArray)));\r\n            //if the current element is smaller than or equal to the pivot, \r\n            if(decreasing){\r\n                if(rawArray[counter].number >= pivot){\r\n                    pivotIndex++;\r\n    \r\n                    //swap the position of the pivot index with that of the counter\r\n                    holder = rawArray[pivotIndex];\r\n                    rawArray[pivotIndex] = rawArray[counter];\r\n                    rawArray[counter] = holder;\r\n                    subframes.push(JSON.parse(JSON.stringify(rawArray)));\r\n    \r\n                    rawArray[pivotIndex].className = \"initial\";\r\n                    rawArray[counter].className = \"initial\";\r\n                    subframes.push(JSON.parse(JSON.stringify(rawArray)));\r\n    \r\n                }\r\n\r\n            }else{\r\n                if(rawArray[counter].number <= pivot){\r\n                    pivotIndex++;\r\n    \r\n                    //swap the position of the pivot index with that of the counter\r\n                    holder = rawArray[pivotIndex];\r\n                    rawArray[pivotIndex] = rawArray[counter];\r\n                    rawArray[counter] = holder;\r\n                    subframes.push(JSON.parse(JSON.stringify(rawArray)));\r\n    \r\n                    rawArray[pivotIndex].className = \"initial\";\r\n                    rawArray[counter].className = \"initial\";\r\n                    subframes.push(JSON.parse(JSON.stringify(rawArray)));\r\n    \r\n                }\r\n            }\r\n\r\n            rawArray[counter].className = \"initial\";\r\n            subframes.push(JSON.parse(JSON.stringify(rawArray)));\r\n\r\n        }\r\n\r\n        rawArray[pivotIndex + 1].className = \"wronglyOrdered\";\r\n        subframes.push(JSON.parse(JSON.stringify(rawArray)));\r\n        \r\n        //swap the end of the array with whatever is on the pivot index\r\n        holder = rawArray[pivotIndex + 1];\r\n        rawArray[pivotIndex + 1] = rawArray[end];\r\n        rawArray[end] = holder;\r\n        subframes.push(JSON.parse(JSON.stringify(rawArray)));\r\n\r\n\r\n        rawArray[end].className = \"initial\";\r\n        rawArray[pivotIndex + 1].className = \"sorted\";\r\n        subframes.push(JSON.parse(JSON.stringify(rawArray)));\r\n\r\n\r\n        return [pivotIndex + 1, subframes];\r\n    }\r\n    \r\n    let frames = [];\r\n    let stack = [];\r\n    let top = - 1;\r\n    stack[++top] = start;\r\n    stack[++top] = end;\r\n\r\n    while(top >= 0){\r\n        end = stack[top--];\r\n        start = stack[top--];\r\n\r\n        let [positionOfNextPivot, subframes] = partition(rawArray, start, end);\r\n        frames = frames.concat(subframes);\r\n\r\n        if(positionOfNextPivot - 1 > start){\r\n            stack[++top] = start;\r\n            stack[++top] = positionOfNextPivot - 1;\r\n        }\r\n\r\n        if(positionOfNextPivot + 1 < end){\r\n            stack[++top] = positionOfNextPivot + 1;\r\n            stack[++top] = end;\r\n        }\r\n    }\r\n    \r\n    return frames;\r\n}\r\n\r\nexport const mergeSort = (decreasing, arr,  n) =>\r\n    { \r\n          \r\n        const  merge = (arr, l, m, r) => \r\n            { \r\n                let i, j, k; \r\n                let n1 = m - l + 1; \r\n                let n2 = r - m; \r\n                let subframes = [];\r\n                \r\n                /* create temp arrays */\r\n                let L = []; \r\n                let R = []; \r\n                \r\n                /* Copy data to temp arrays L[] \r\n                and R[] */\r\n                for (i = 0; i < n1; i++) \r\n                    L[i] = arr[l + i]; \r\n\r\n                for (j = 0; j < n2; j++) \r\n                    R[j] = arr[m + 1+ j]; \r\n                \r\n                /* Merge the temp arrays back into \r\n                arr[l..r]*/\r\n                i = 0; \r\n                j = 0; \r\n                k = l; \r\n                let holder;\r\n                while (i < n1 && j < n2) \r\n                { \r\n\r\n                    //find index of L[i] and index of R[j] in raw\r\n                    let positionL;\r\n                    let positionR;\r\n                    let indexInRawL = L[i].indexInArray;\r\n                    let indexInRawR = R[j].indexInArray;\r\n\r\n                    //find L[i] position in the raw array;\r\n                    for(let counter = 0; counter < arr.length; counter++){\r\n                        if(indexInRawL === arr[counter].indexInArray) positionL = counter;\r\n                    }\r\n                    //find L[i] position in the raw array;\r\n                    for(let counter = 0; counter < arr.length; counter++){\r\n                        if(indexInRawR === arr[counter].indexInArray) positionR = counter;\r\n                    }\r\n\r\n                    arr[positionL].className = \"inComparison\";\r\n                    arr[positionR].className = \"inComparison\";\r\n                    subframes.push(JSON.parse(JSON.stringify(arr)));\r\n\r\n                    if(decreasing){\r\n\r\n                        if (L[i].number >= R[j].number) \r\n                        { \r\n                            arr[positionL].className = \"wronglyOrdered\";\r\n                            arr[k].className = \"wronglyOrdered\";\r\n                            subframes.push(JSON.parse(JSON.stringify(arr)));\r\n                            \r\n                            //perform a swap instead of an over right;\r\n                            holder = arr[k]\r\n                            arr[k] = arr[positionL];\r\n                            arr[positionL] = holder; \r\n                            i++; \r\n                            subframes.push(JSON.parse(JSON.stringify(arr)));\r\n\r\n                            arr[positionL].className = \"initial\";\r\n                            arr[k].className = \"initial\";\r\n                            subframes.push(JSON.parse(JSON.stringify(arr)));\r\n                        } \r\n                        else\r\n                        { \r\n                            arr[positionR].className = \"wronglyOrdered\";\r\n                            arr[k].className = \"wronglyOrdered\";\r\n                            subframes.push(JSON.parse(JSON.stringify(arr)));\r\n\r\n                            //perform a swap instead of an over right;\r\n                            holder = arr[k]\r\n                            arr[k] = arr[positionR];\r\n                            arr[positionR] = holder; \r\n                            j++; \r\n                            subframes.push(JSON.parse(JSON.stringify(arr)));\r\n\r\n                            arr[positionR].className = \"initial\";\r\n                            arr[k].className = \"initial\";\r\n                            subframes.push(JSON.parse(JSON.stringify(arr))); \r\n                        }\r\n\r\n                    }else{\r\n                        if (L[i].number <= R[j].number) \r\n                        { \r\n                            arr[positionL].className = \"wronglyOrdered\";\r\n                            arr[k].className = \"wronglyOrdered\";\r\n                            subframes.push(JSON.parse(JSON.stringify(arr)));\r\n                            \r\n                            //perform a swap instead of an over right;\r\n                            holder = arr[k]\r\n                            arr[k] = arr[positionL];\r\n                            arr[positionL] = holder; \r\n                            i++; \r\n                            subframes.push(JSON.parse(JSON.stringify(arr)));\r\n\r\n                            arr[positionL].className = \"initial\";\r\n                            arr[k].className = \"initial\";\r\n                            subframes.push(JSON.parse(JSON.stringify(arr)));\r\n                        } \r\n                        else\r\n                        { \r\n                            arr[positionR].className = \"wronglyOrdered\";\r\n                            arr[k].className = \"wronglyOrdered\";\r\n                            subframes.push(JSON.parse(JSON.stringify(arr)));\r\n\r\n                            //perform a swap instead of an over right;\r\n                            holder = arr[k]\r\n                            arr[k] = arr[positionR];\r\n                            arr[positionR] = holder; \r\n                            j++; \r\n                            subframes.push(JSON.parse(JSON.stringify(arr)));\r\n\r\n                            arr[positionR].className = \"initial\";\r\n                            arr[k].className = \"initial\";\r\n                            subframes.push(JSON.parse(JSON.stringify(arr))); \r\n                        } \r\n                    }\r\n\r\n\r\n                    k++;\r\n                    arr[positionL].className = \"initial\";\r\n                    arr[k].className = \"initial\";\r\n                    arr[positionR].className = \"initial\";\r\n                    subframes.push(JSON.parse(JSON.stringify(arr)));  \r\n                } \r\n\r\n                for(let counter = 0; counter < arr.length; counter++){\r\n                    if(arr[counter].className !== \"initial\") arr[counter].className = \"initial\";\r\n                }\r\n                \r\n                /* Copy the remaining elements of  \r\n                L[], if there are any */\r\n                while (i < n1) \r\n                { \r\n                    arr[k] = L[i]; \r\n                    i++; \r\n                    k++; \r\n                } \r\n                \r\n                /* Copy the remaining elements of \r\n                R[], if there are any */\r\n                while (j < n2) \r\n                { \r\n                    arr[k] = R[j];\r\n                    \r\n                    j++; \r\n                    k++; \r\n                } \r\n                subframes.push(JSON.parse(JSON.stringify(arr))); \r\n\r\n                return subframes;\r\n            }\r\n        let frames = []; \r\n        // For current size of subarrays to \r\n        // be merged curr_size varies from  \r\n        // 1 to n/2 \r\n        let curr_size;  \r\n                      \r\n        // For picking starting index of  \r\n        // left subarray to be merged \r\n        let left_start; \r\n                          \r\n          \r\n        // Merge subarrays in bottom up  \r\n        // manner. First merge subarrays  \r\n        // of size 1 to create sorted  \r\n        // subarrays of size 2, then merge \r\n        // subarrays of size 2 to create  \r\n        // sorted subarrays of size 4, and \r\n        // so on. \r\n        for (curr_size = 1; curr_size <= n-1;  \r\n                      curr_size = 2*curr_size) \r\n        { \r\n              \r\n            // Pick starting point of different \r\n            // subarrays of current size \r\n            for (left_start = 0; left_start < n-1; \r\n                        left_start += 2*curr_size) \r\n            { \r\n                // Find ending point of left  \r\n                // subarray. mid+1 is starting  \r\n                // point of right \r\n                let mid = Math.min(left_start + curr_size - 1, n-1); \r\n          \r\n                let right_end = Math.min(left_start  \r\n                             + 2*curr_size - 1, n-1); \r\n          \r\n                // Merge Subarrays arr[left_start...mid] \r\n                // & arr[mid+1...right_end] \r\n                let subframes = merge(arr, left_start, mid, right_end); \r\n                frames = frames.concat(subframes);\r\n            } \r\n        } \r\n\r\n        return frames;\r\n    } \r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './components/App';\r\nimport 'bootstrap/dist/css/bootstrap.min.css';\r\nimport './styles/global.css';\r\n\r\nconst rootNode = document.querySelector(\"#root\");\r\nReactDOM.render(\r\n    <App/>, rootNode\r\n);"],"sourceRoot":""}